(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
  typeof define === 'function' && define.amd ? define(factory) :
  (global = global || self, global.apiCodeBuilder = factory());
}(this, function () { 'use strict';

  function withTab(code, tab, tabSize = 2) {
      const oneTab = Array(tabSize).fill(' ').join('');
      return Array(tab).fill(oneTab).join('') + code;
  }
  function format (lines, tabSize = 2) {
      let tab = 0;
      return lines
          .map(line => {
          if (line.trim().startsWith('}'))
              tab--;
          const code = withTab(line, tab, tabSize);
          if (line.endsWith('{'))
              tab++;
          return code;
      })
          .join('\n');
  }

  const upperFirstCase = (name) => {
      if (!name || !name.length)
          return '';
      return name[0].toUpperCase() + name.slice(1);
  };
  const lintVariable = (name) => name.replace(/[^\w]/g, '');

  const getRef = ($ref) => lintVariable($ref.replace(/^.*\/([^/]*)$/, '$1'));
  const getEnums = (enums) => `(${enums.map(item => (typeof item === 'string'
    ? `'${item}'` : item)).join('|')})`;
  function DataType(property) {
      if (!property)
          return 'any';
      return property.$ref
          ? getRef(property.$ref)
          : property.items
              ? DataType(property.items) + '[]'
              : property.enum
                  ? getEnums(property.enum)
                  : property.type === 'integer'
                      ? 'number'
                      : property.type === 'file'
                          ? 'any'
                          : property.type === 'object'
                              ? 'any'
                              : property.type || 'any';
  }

  function Typing (definitions, version) {
      if (version === 'js')
          return jsdocTypedef(definitions);
      const lines = [];
      Object.entries(definitions).forEach(([key, definition]) => {
          lines.push(`export interface ${lintVariable(key)} {`);
          definition.properties && Object.entries(definition.properties).forEach(([key, property]) => {
              if (property.description && property.description !== key)
                  lines.push(`/** ${property.description} */`);
              const required = definition.required && definition.required.includes(key)
                  ? '' : '?';
              lines.push(`${key}${required}: ${DataType(property)}`);
          });
          lines.push(`}`);
      });
      return lines;
  }
  function jsdocTypedef(definitions) {
      const lines = [];
      Object.entries(definitions).forEach(([key, definition]) => {
          lines.push('/**');
          lines.push(` * @typedef ${lintVariable(key)}`);
          definition.properties && Object.entries(definition.properties).forEach(([key, property]) => {
              if (!(definition.required && definition.required.includes(key)))
                  key = `[${key}]`;
              let line = ` * @property {${DataType(property)}} ${key}`;
              if (property.description && property.description !== key)
                  line += ' ' + property.description;
              lines.push(line);
          });
          lines.push(` */`);
      });
      return lines;
  }

  function getGroupNameFrom(pathName) {
      return pathName.split('/').filter(x => x)[0] || 'root';
  }
  function getApiNameFrom(pathName) {
      return pathName
          .split('/')
          .filter(x => x)
          .slice(1)
          .map(item => item.replace(/\{(.*)\}/, (_, $1) => `By${upperFirstCase($1)}`))
          .map(lintVariable)
          .map(upperFirstCase)
          .join('')
          || '';
  }
  function initGroup(pathNames) {
      const groups = {};
      const groupNames = new Set();
      pathNames.forEach(pathname => {
          groupNames.add(getGroupNameFrom(pathname));
      });
      groupNames.forEach(groupName => {
          groups[groupName] = { apis: {} };
      });
      return groups;
  }
  function Groups (paths, tags) {
      const groups = initGroup(Object.keys(paths));
      Object.keys(paths).forEach(path => {
          const groupName = getGroupNameFrom(path);
          const group = groups[groupName];
          Object.entries(paths[path]).forEach(([method, ctx]) => {
              group.apis[method + getApiNameFrom(path)] = {
                  path, method, ...ctx
              };
          });
      });
      return groups;
  }

  function comment (lines) {
      lines = lines.filter(x => x);
      if (!lines.length)
          return [];
      if (lines.length === 1)
          return [`/** ${lines[0]} */`];
      return [
          '/**',
          ...lines.map(line => (` * ${String(line).replace(/\n/g, ' ').trim()}`)),
          ' */',
      ];
  }

  function ParameterDataType(parameter) {
      return DataType(parameter.schema || parameter);
  }
  function ParameterGroup(parameters = []) {
      const p = {
          path: [],
          params: [],
          formData: [],
      };
      parameters.forEach(parameter => {
          switch (parameter.in) {
              case 'path':
                  p.path.push(parameter);
                  break;
              case 'query':
                  p.params.push(parameter);
                  break;
              case 'body':
                  p.data = parameter;
                  break;
              case 'formData':
                  p.formData.push(parameter);
          }
      });
      if (p.path.length === 0)
          delete p.path;
      if (p.params.length === 0)
          delete p.params;
      if (p.formData.length === 0)
          delete p.formData;
      return p;
  }
  ParameterGroup.string = function (parameterGroup, baseTypeName, version) {
      if (version === 'js')
          return Object.keys(parameterGroup).join(', ');
      return Object.entries(parameterGroup)
          .map(([name, parameters]) => name === 'data'
          ? `data: ${ParameterDataType(parameters)}`
          : `${name}: ${(baseTypeName + upperFirstCase(name))}`)
          .join(', ');
  };
  ParameterGroup.jsdocObj = function (parameterGroup) {
      return Object.entries(parameterGroup)
          .map(([name, parameters]) => name === 'data'
          ? `@param {${ParameterDataType(parameters)}} ${name}`
          : `@param {{ ${createTypingSnippet(parameters)} }} ${name}`);
  };
  ParameterGroup.axiosConfig = function (parameterGroup) {
      const axiosConfig = ['method'];
      if (parameterGroup.params)
          axiosConfig.push('params');
      if (parameterGroup.formData || parameterGroup.data)
          axiosConfig.push('data');
      return axiosConfig.join(', ');
  };
  function required(required) {
      if (required)
          return '';
      return '?';
  }
  function createTypingSnippet(parameters) {
      return parameters.map(parameter => (`${parameter.name}${required(parameter.required)}: ${ParameterDataType(parameter)}`)).join(', ');
  }
  function TypingfromParameters(typeName, parameters, version) {
      typeName = lintVariable(typeName);
      if (version === 'js') {
          return comment([
              `@typedef ${typeName}`,
              ...parameters.map(parameter => (`@property {${ParameterDataType(parameter)}} ${parameter.name}`))
          ]);
      }
      return [
          `export interface ${typeName} {`,
          ...parameters.map(parameter => {
              const key = /^\w+$/.test(parameter.name) ? parameter.name : `"${parameter.name}"`;
              return `${key}${required(parameter.required)}: ${ParameterDataType(parameter)}`;
          }),
          '}'
      ];
  }

  function urlResolve (url) {
      url = url.replace(/\{([^{}]+)\}/g, (_, $1) => `\${path.${$1}}`);
      if (/\$\{.+\}/.test(url))
          return '`' + url + '`';
      else
          return `'${url}'`;
  }

  // TODO: 分类 to reduce code
  function formdataCode () {
      return [
          'const data = new FormData()',
          'Object.entries(formData).forEach(([name, value]) => {',
          'if (value === undefined) return',
          'if (value instanceof Array)',
          '  value.forEach(value => data.append(name, value))',
          'else',
          '  data.append(name, value)',
          '})',
      ];
  }

  function createApiCode (config) {
      if (!config.version)
          config.version = 'js';
      const typingCodes = [];
      if (config.definitions)
          typingCodes.push(...Typing(config.definitions, config.version));
      const groups = Groups(config.paths);
      const codes = [];
      codes.push('// this file may be overwrite by api code builder, don\'t change it. Go to api.config.json to config output file', '// 本文件可能会被 api code builder 重写覆盖，请勿修改它。配置 api.config.json 来修改生成文件', '/* eslint-disable */');
      codes.push(`import axios from '${config.axiosFrom || 'axios'}'`, '');
      if (config.version === 'ts')
          codes.push('import { AxiosRequestConfig, AxiosPromise } from \'axios\'');
      if (config.baseURL && !config.axiosFrom)
          codes.push(`axios.defaults.baseURL = '${config.baseURL}'`, '');
      codes.push('if (!axios.defaults.baseURL)', `  axios.defaults.baseURL = '${config.baseURL}'\n`);
      codes.push('export default {');
      Object.entries(groups).forEach(([groupName, group], i, { length }) => {
          codes.push(`${groupName}: {`);
          Object.entries(group.apis).forEach(([apiName, ctx], i, { length }) => {
              const parameterGroup = ParameterGroup(ctx.parameters);
              codes.push(...comment([
                  ctx.summary,
                  ctx.description && `@explain ${ctx.description}`,
                  ...config.version == 'js' ? ParameterGroup.jsdocObj(parameterGroup) : [],
              ]));
              const baseTypeName = upperFirstCase(groupName) + upperFirstCase(apiName);
              if (config.version === 'ts')
                  Object.entries(parameterGroup).forEach(([paramName, parameters]) => {
                      if (paramName === 'data')
                          return;
                      typingCodes.push(...TypingfromParameters(baseTypeName + upperFirstCase(paramName), parameters, config.version));
                  });
              const AXIOS_CONFIG_NAME = 'axiosConfig';
              const paramString = [
                  ParameterGroup.string(parameterGroup, baseTypeName, config.version),
                  config.version === 'ts' ? `${AXIOS_CONFIG_NAME}?: AxiosRequestConfig` : AXIOS_CONFIG_NAME
              ].filter(x => x).join(', ');
              let responseType;
              if (!ctx.responses || !ctx.responses['200']) {
                  responseType = 'void';
              }
              else {
                  responseType = DataType(ctx.responses['200'].schema);
                  if (config.customResponse)
                      responseType = `Promise<${config.customResponse.replace('RESPONSE', responseType)}>`;
                  else
                      responseType = `AxiosPromise<${responseType}>`;
                  if (config.version === 'ts')
                      responseType = `: ${responseType}`;
                  else
                      responseType = '';
              }
              codes.push(`${apiName}(${paramString})${responseType} {`);
              codes.push(`const method = '${ctx.method}'`);
              const axiosConfig = ParameterGroup.axiosConfig(parameterGroup);
              if (parameterGroup.formData)
                  codes.push(...formdataCode());
              codes.push(`return axios(${urlResolve(ctx.path)}, { ${axiosConfig}, ...${AXIOS_CONFIG_NAME} })` + (config.customResponse ? ' as any' : ''));
              codes.push('}' + (length !== i + 1 ? ',' : ''));
          });
          codes.push('}' + (length !== i + 1 ? ',' : ''));
      }),
          codes.push('}\n');
      codes.push(...typingCodes, '');
      return format(codes);
  }

  var main = {
      buildApi: createApiCode
  };

  return main;

}));
